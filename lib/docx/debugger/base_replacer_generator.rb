# frozen_string_literal: true

module Docx
  module Debugger
    class BaseReplacerGenerator
      def initialize(config, results)
        @config = config
        @results = results
        @timestamp = Time.now.strftime("%Y%m%d_%H%M%S")
      end

      def generate!
        class_name = generate_class_name
        file_name = "#{class_name.gsub(/([a-z\d])([A-Z])/, '\1_\2').downcase}.rb"
        file_path = File.join(Dir.pwd, file_name)
        
        File.write(file_path, generate_class_content(class_name))
        file_path
      end

      private

      def generate_class_name
        base = @config.placeholder_type.to_s.split('_').map(&:capitalize).join
        "#{base}Replacer"
      end

      def generate_class_content(class_name)
        placeholder_names = @config.placeholders.map { |p| p[:name] }
        
        <<~RUBY
          # frozen_string_literal: true
          
          # Generated by docx-br debugger on #{Time.now}
          # Template validation results:
          #   - Total placeholders: #{@results[:total]}
          #   - Successfully validated: #{@results[:successful]}
          #   - Pattern type: #{@config.placeholder_type}
          
          require 'docx'
          
          class #{class_name}
            attr_reader :document, :replacements
            
            # Placeholder definitions
            PLACEHOLDERS = {
          #{generate_placeholder_definitions}
            }.freeze
            
            def initialize(template_path)
              @document = Docx::Document.open(template_path)
              @replacements = {}
              initialize_default_values
            end
            
            # Set replacement values
          #{generate_setter_methods}
            
            # Replace all placeholders in the document
            def replace_all!
              validate_replacements!
              
              @document.paragraphs.each do |paragraph|
                PLACEHOLDERS.each do |key, placeholder_info|
                  value = @replacements[key]
                  next unless value
                  
                  # Using substitute_across_runs to handle fragmented placeholders
                  paragraph.substitute_across_runs(placeholder_info[:pattern], value.to_s)
                end
              end
              
              # Also replace in tables if present
              @document.tables.each do |table|
                table.rows.each do |row|
                  row.cells.each do |cell|
                    cell.paragraphs.each do |paragraph|
                      PLACEHOLDERS.each do |key, placeholder_info|
                        value = @replacements[key]
                        next unless value
                        
                        paragraph.substitute_across_runs(placeholder_info[:pattern], value.to_s)
                      end
                    end
                  end
                end
              end
              
              self
            end
            
            # Save the document
            def save(output_path)
              @document.save(output_path)
            end
            
            # Replace and save in one step
            def process!(output_path)
              replace_all!
              save(output_path)
            end
            
            # Get list of required placeholders
            def required_placeholders
              PLACEHOLDERS.keys
            end
            
            # Check if all placeholders have values
            def ready?
              missing_placeholders.empty?
            end
            
            # Get list of placeholders without values
            def missing_placeholders
              PLACEHOLDERS.keys.select { |key| @replacements[key].nil? || @replacements[key].to_s.empty? }
            end
            
            private
            
            def initialize_default_values
              PLACEHOLDERS.keys.each do |key|
                @replacements[key] = nil
              end
            end
            
            def validate_replacements!
              missing_vals = missing_placeholders
              unless missing_vals.empty?
                raise ArgumentError, "Missing values for placeholders: \#{missing_vals.join(', ')}"
              end
            end
          end
          
          # Example usage:
          # replacer = #{class_name}.new('template.docx')
          #{generate_example_usage(placeholder_names)}
          # replacer.process!('output.docx')
        RUBY
      end

      def generate_placeholder_definitions
        definitions = @config.placeholders.map do |placeholder|
          key = placeholder[:name].downcase.to_sym
          pattern = placeholder[:pattern].inspect
          formatted = placeholder[:formatted]
          
          <<~DEF.chomp
                #{key}: {
                  pattern: #{pattern},
                  formatted: "#{formatted}",
                  description: "Replaces #{formatted}"
                }
          DEF
        end
        
        definitions.join(",\n")
      end

      def generate_setter_methods
        methods = @config.placeholders.map do |placeholder|
          name = placeholder[:name].downcase
          
          <<~METHOD.chomp
            def #{name}=(value)
              @replacements[:#{name}] = value
            end
          METHOD
        end
        
        methods.join("\n            \n          ")
      end

      def generate_example_usage(placeholder_names)
        examples = placeholder_names.map do |name|
          "# replacer.#{name.downcase} = 'Your Value'"
        end
        examples.join("\n          ")
      end
    end
  end
end